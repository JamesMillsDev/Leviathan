using Leviathan.Configuration;
using Leviathan.Debugging;
using Leviathan.Events;
using Leviathan.GameObjects;
using Leviathan.GameStates;
using Leviathan.Resources;

using Raylib_cs;

using System.Reflection;

namespace Leviathan
{
	/// <summary></summary>
	public sealed class Application
	{
		/// <summary>The raylib version of the logger (used for all Raylib calls)</summary>
		internal static readonly Logger raylibLogger = new("Raylib");

		/// <summary>A global accessor for the window context. Allows the access of screen size and background color.</summary>
		public static ref Window? Window => ref instance!.window;

		/// <summary>The Application's singleton instance. Only used to access the Window value.</summary>
		private static Application? instance;

		/// <summary>Runs the whole game, initialising the game contexts.</summary>
		/// <typeparam name="GAME">The game's class that will automatically generated.</typeparam>
		public static void Run<GAME>() where GAME : Game, new()
		{
			if(!LeviathanLoader.HasLoaded)
				LeviathanLoader.Load();

			GAME game = new();
			instance = new Application(game);
			instance.Run();
		}

		public static void Quit() => instance!.running = false;

		private readonly List<ILeviathanModule> modules = new();

		/// <summary></summary>
		private readonly Config<ApplicationConfigData>? applicationConfig;

		/// <summary></summary>
		private long exitKey;

		/// <summary></summary>
		private long configReloadKey;

		/// <summary></summary>
		private long gizmosKey;

		/// <summary>The window context. Can be accessed globally by <see cref="Window"/>.</summary>
		private Window? window;

		/// <summary>The game instance. Auto-Generated by the <see cref="Run{GAME}"/> function.</summary>
		private readonly Game? game;

		private bool running = true;

		private Application(Game? _game)
		{
			try
			{
				game = _game;

				// Create and load the application config
				applicationConfig = new Config<ApplicationConfigData>("application");

				// Load in the application and debug specific keys
				exitKey = applicationConfig.GetValue<long>("application.quitKey");
				configReloadKey = applicationConfig.GetValue<long>("debug.reloadConfigKey");
				gizmosKey = applicationConfig.GetValue<long>("debug.toggleGizmosKey");

				// Set the exit key and stop raylib from logging normally
				Raylib.SetExitKey((KeyboardKey) exitKey);
				Raylib.SetTraceLogLevel(TraceLogLevel.LOG_NONE);

				// Create the window instance
				window = new Window(applicationConfig);

				LoadModules();
			}
			catch(Exception e)
			{
				raylibLogger.LogException(e);
			}
		}

		private void LoadModules()
		{
			foreach(Assembly assembly in LeviathanLoader.modules)
			{
				Type[] types = assembly.GetTypes();
				Console.WriteLine(assembly.FullName);
				foreach(Type type in types)
				{
					if(type.GetInterfaces().Contains(typeof(ILeviathanModule)))
					{
						object? m = Activator.CreateInstance(type);
						if(m is ILeviathanModule module)
							modules.Add(module);
					}
				}
			}
		}

		/// <summary>Attempt to open the game and the window.</summary>
		/// <returns>True if the game opened correctly, false if ANYTHING failed.</returns>
		private bool Open()
		{
			try
			{
				// Open the window and load the managers
				window?.Open();
				GameObjectManager.CreateInstance();
				GameStateManager.CreateInstance();
				ResourceManager.CreateInstance();
				
				modules.ForEach(_module => _module.Load());

				// Open the game
				game?.Open();

				// Attempt to load the audio system
				if(applicationConfig!.GetValue<bool>("application.audioEnabled"))
					Raylib.InitAudioDevice();
			}
			catch(Exception e)
			{
				// Log out the exception that was thrown, destroy the game instance and return
				raylibLogger.LogException(e);

				return false;
			}

			return true;
		}

		/// <summary>Closes down the application system.</summary>
		private void Close()
		{
			// Attempt to shut down the audio device
			if(Raylib.IsAudioDeviceReady())
				Raylib.CloseAudioDevice();

			modules.ForEach(_module => _module.Unload());
			
			// Close the game
			game?.Close();

			// Close the window context and cleanup the managers
			ResourceManager.DestroyInstance();
			GameStateManager.DestroyInstance();
			GameObjectManager.DestroyInstance();
			window?.Close();
		}

		private void Run()
		{
			// Try to open the game
			if(!Open())
				return;

			while(running)
			{
				Time.Tick();

				if(Raylib.IsKeyPressed((KeyboardKey) configReloadKey))
					Reconfigure();

				if(Raylib.IsKeyPressed((KeyboardKey) gizmosKey))
					Gizmos.drawGizmos = !Gizmos.drawGizmos;

				try
				{
					window?.Tick();
					
					modules.ForEach(_module => _module.Tick());

					// Tick the game state manager and object manager
					GameStateManager.Tick();
					GameObjectManager.Tick();

					window?.Render();

					// Render the game states and the objects 
					GameStateManager.Render();
					GameObjectManager.Render();
					
					modules.ForEach(_module => _module.Render());

					Gizmos.Render(applicationConfig, modules);
				}
				catch(Exception e)
				{
					raylibLogger.LogException(e);
				}

				if(Raylib.WindowShouldClose())
					running = false;
			}

			// Close the game
			Close();
		}

		/// <summary>Rebuild the configs and reconfigure all components in the game.</summary>
		private void Reconfigure()
		{
			EventBus.Raise(new ConfigReloadEvent());
			
			// Reload the global key values
			exitKey = applicationConfig!.GetValue<long>("application.quitKey");
			configReloadKey = applicationConfig!.GetValue<long>("debug.reloadConfigKey");
			gizmosKey = applicationConfig!.GetValue<long>("debug.toggleGizmosKey");

			// Set the new exit key
			Raylib.SetExitKey((KeyboardKey) exitKey);
		}
	}
}